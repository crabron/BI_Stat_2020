---
title: "Mouse_project"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(car)
library(MASS)
library(gridExtra)
library(corrplot)
library(multcomp)
library(readxl)
library(plotly)

```

## Импорт данных

```{r}

mice <- read_xls("~/storage/trash/BI/RS/Data_Cortex_Nuclear.xls")

mice <- mice %>%  
  mutate(class = as.factor(class)) %>% 
  mutate(Behavior = as.factor(Behavior)) %>% 
  mutate(Genotype = as.factor(Genotype)) %>% 
  mutate(Treatment = as.factor(Treatment)) 
mice <- mice %>% 
  separate(MouseID, c("Mouse", "Repeat"), remove = FALSE) %>% 
  mutate(Mouse = as.factor(Mouse)) %>% 
  mutate(Repeat = as.factor(Repeat))
mice <- mice %>% 
  relocate(c(Genotype, Repeat, Treatment, Behavior, class, ERBB4_N, BDNF_N), .after = Mouse) 
mice

```

### Сколько мышей?

```{r}

length(levels(mice$Mouse))

```

### Какие группы можно выделить?

Группы разные по размеру, много na
Что вводили мышкам для улучшения обучения?

```{r}

summary_list <- lapply(mice, summary)

summary_list$Treatment
```

Какие были мышки(дауны или нет)
```{r}
summary_list$Genotype
```

Насколько мышки хотели учиться?
```{r}
summary_list$Behavior
```

Есть отдельные колонки с ошеломляющим количеством пустых значений.

```{r}

na_count <-sapply(mice, function(y) sum(length(which(is.na(y)))))
sort(na_count, decreasing = TRUE)

```

## Есть ли различия в уровне продукции BDNF_N в зависимости от класса?

Попробуем сделать Anova
Сначала боксплот, распределены ли нормально данные по классу?

```{r}

ggplot(mice, aes(x = class, y = BDNF_N)) + geom_boxplot() + geom_point() + ggtitle("Просто боксплот")


```

Построим линейную модель и график остатков, чтобы удостоверится в возможности применения Anova

```{r}
mice_prot_lm <- lm(BDNF_N ~ class, data = mice)
ggplot(mice_prot_lm, aes(x = class, y = .stdresid)) + geom_boxplot() + ggtitle("График остатков")

```

Анова

```{r}
mice_anova <- Anova(mice_prot_lm)
mice_anova
```

И постхок для Ановы.

```{r}
post_hoch <- glht(mice_prot_lm, linfct = mcp(class = "Tukey"))
result <- summary(post_hoch)
result

```

Да, по части классов отличия есть и они достоверны.

## Попробовать построить линейную модель


Обрежем данные, уберём столбцы с большим количеством пропущенных значений и нечисловыми данными.

```{r}
mice_d <- mice %>% dplyr::select(-c(MouseID, Mouse, Repeat, Genotype, Treatment, Behavior, class, ARC_N, BCL2_N , H3MeK4_N , BAD_N, EGR1_N, H3AcK18_N, pCFOS_N))
mice_d
```

```{r}
lm_mod <- lm(ERBB4_N ~ ., data=mice_d)
summary(lm_mod)
```

Общее значение модели довольно высокое, часть факторов назодится в линейной зависимости.

Анализ на мультиколлинеарность показывает, что предикторы влияют друг на друга

```{r}

sort(car::vif(lm_mod), decreasing = TRUE)

```

График остатков для всех данных

```{r, fig.height=4, fig.width=5}
gg_resid <- ggplot(data = lm_mod, aes(x = .fitted, y = .stdresid)) + 
  geom_point() + 
  geom_hline(yintercept = 0) +
  geom_smooth(formula = y ~ x, method = "lm") +
  geom_hline(yintercept = 2, color = "red") +
  geom_hline(yintercept = -2, color = "red")
gg_resid
```

Если посмотреть корреляции - видно, что предикторы структурированы и построение линейной модели в данном случае не самое корректное решение.

```{r,fig.height=12, fig.width=12, results=FALSE}

mice_w_na <- mice_d
mice_w_na[is.na(mice_w_na)] <- 0
df_cor = cor(mice_w_na, use = "pairwise.complete.obs")
corrplot.mixed(df_cor)

```

### Сделайте PCA

https://stackoverflow.com/questions/44393823/3d-biplot-in-plotly-r

```{r}

pca <- princomp(mice_w_na, scores=T, cor=T, na.action = "na.omit")
summary(pca)

```

Факторные нагрузки

```{r}
screeplot(pca)
```

Трёхмерный график

```{r}

scores <- pca$scores
x <- scores[,1]
y <- scores[,2]
z <- scores[,3]

loads <- pca$loadings

scale.loads <- 5



p <- plot_ly() %>%
  add_trace(x=x, y=y, z=z,
            type="scatter3d", mode="markers",
            marker = list(color=y, 
               colorscale = c("#FFE1A1", "#683531"), 
               opacity = 0.7)) 

for (k in 1:nrow(loads)) {
   x <- c(0, loads[k,1])*scale.loads
   y <- c(0, loads[k,2])*scale.loads
   z <- c(0, loads[k,3])*scale.loads
   p <- p %>% add_trace(x=x, y=y, z=z,
            type="scatter3d", mode="lines",
            line = list(width=4),
            opacity = 0.8) 
}
print(p)

```









